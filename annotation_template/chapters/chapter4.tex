\chapter{Реализация}
\label{chap:impl}

\section{Обзор стека}
\label{sec:architecture}
В этом разделе описывается стек технологий, используемый в проекте: Elixir, Yul, компилятор Solidity.
% TODO: добавить уточнение, что Elixir является основой синтаксиса и исходного языка компилятора
\subsection{Выбор Elixir}
Здесь приводится обоснование выбора Elixir:
\begin{itemize}
    \item Один из самых популярных обозревателей блокчейна с открытым исходным кодом, Blockscout\footnote{\href{https://www.blockscout.com/}{https://www.blockscout.com} -- Официальный сайт Blockscout}, написан на языке Elixir. Исходя из этого, можно сказать, что Elixir хорошо известен в Web3-сообществе.
    \item Наша команда обладает значительным опытом в этом языке программирования.
    \item Elixir имеет открытый исходный код, поэтому мы можем легко использовать его механизмы для токенизации и парсинга Elixireum.
\end{itemize}

\subsection{Выбор Yul}
\begin{itemize}
    \item Изначально наша стратегия заключалась в компиляции Elixireum непосредственно в байткод EVM. Впоследствии мы переключились на промежуточное представление (ПП), выбрав Yul как ПП, соответствующее нашим требованиям. Преимущества этого решения заключаются в следующем:
        \begin{itemize}
            \item Совместимость со всеми версиями EVM, что устраняет необходимость в разработке версий. 
            \item Избежание реализации таких примитивов, как вызовы функций, управление переменными и стеком, что позволяет высвободить ресурсы для расширения функциональных возможностей языка.
            \item Снижение потребления газа благодаря оптимизатору компилятора Solidity.
        \end{itemize}
      Несмотря на эти соображения, данный выбор имеет некоторые ограничения, а именно:
        \begin{itemize}
            \item Зависимость от компилятора Solidity для Elixireum.
            \item Нерешенная ошибка\footnote{\href{https://github.com/ethereum/solidity/issues?q=is:issue+is:open+StackTooDeepError}{https://github.com/ethereum/solidity/issues?q=is:issue+is:open+StackTooDeepError}} в компиляторе Solidity, в нашем случае она проявляется для больших смарт-контрактов Elixireum при компиляции с отключенным оптимизатором. Ошибка приводит к невозможности работать с большим количеством переменных и большой глубиной стека.
        \end{itemize}
      Никаких существенных недостатков по сравнению с прямой компиляцией в байткод EVM.
\end{itemize}

\section{Технические детали}
\label{sec:tech_details}

\subsection{Организация памяти}
\label{sec:memory_organization}

В нашей языковой реализации мы решили хранить все переменные времени выполнения в энергозависимой памяти EVM. Это решение оправдано низкими газовыми затратами, связанными с операциями с памятью, и простотой реализации. Мы рассматривали две альтернативы: временное хранилище, которое дороже памяти, и стек, который предполагает более сложное управление.

В сгенерированном коде Yul переменная определяется как указатель на область памяти, где хранится ее значение. В этом указателе первый байт зарезервирован для номера типа, а последующие байты содержат само значение для простых случаев. Для более сложных случаев, таких как списки и кортежи, первый байт по-прежнему указывает на тип, затем следует слово\footnote{в данном контексте слово - это 32 байта}, определяющее количество элементов, а затем сами элементы, каждый из которых хранится как встроенная переменная (тип + значение). Для строк или байтовых массивов первый байт указывает тип (1 для строк, 102 для байтовых массивов), следующее слово определяет количество байт, а затем собственно байты.

Поскольку мы разработали функциональный язык, мы должны следовать одному из его фундаментальных принципов - неизменяемости. Это означает, что каждая операция присваивания создает новую переменную. На практике мы «забываем» предыдущий указатель, присваиваем новый указатель и помещаем переменную в новое место. Каждая новая переменная должна храниться последовательно после предыдущей. Для этого в сгенерированном коде Yul мы определяем переменную offset\$. Эта переменная содержит адрес памяти, где будет храниться следующая переменная. В качестве решения для пограничных случаев мы обновляем эту переменную с помощью Yul функции msize, присваивая переменной offset\$ текущий размер памяти, округленный до одного слова.

В синтаксисе Elixireum нет спецификаторов типов для переменных. Для работы с динамическими типами мы установили несколько принципов, на которых построена наша система типов:
\begin{itemize}
  \item Возвращаемые значения публичных функций должны строго соответствовать указанным типам; в противном случае, будет вызвана операция revert\footnote{opcode, который останавливает текущее выполнение и выбрасывает ошибку. Все изменения состояния будут отменены}.
  \item Для литералов тип определяется во время компиляции.
  \item Тип хранится в первом байте переменной.
\end{itemize}

Пример работы со строками в Elixireum выглядит следующим образом:

\begin{lstlisting}[caption={Код Elixireum для регистра строк}, language=elixir]
  a = "abc" # 0x616263
\end{lstlisting}
  
Соответствующий Yul код, сгенерированный для этого случая строки, таков:

\begin{lstlisting}[caption={Сгенерированный Yul-код для случая строки}, language=yul]
  let offset$ := msize() 
  let a$ := offset$ 
  mstore8(offset$, 1)
  offset$ := add(offset$, 1)
  mstore(offset$, 3)
  offset$ := add(offset$, 32) 
  mstore(offset$, 0x61626300...00)
  offset$ := add(offset$, 3) 
\end{lstlisting}

В этом коде Yul переменная a\$ определена как указатель памяти. Тип переменной сохраняется с помощью mstore8, затем с помощью mstore сохраняется размер байта строки. После хранения самой строки offset\$ увеличивается на размер строки (3 байта).

Пример работы со списками в Elixireum выглядит следующим образом:

\begin{lstlisting}[caption={Код Elixireum для случая списка}, language=elixir]
  a = [1, true, "abc"]
\end{lstlisting}
  
\begin{lstlisting}[caption={Сгенерированный yul-код для случая строки}, language=yul]
  let offset$ := msize()
  
  let var0$ := offset$
  ...  
  let bool_var1$ := offset$
  ...
  let str2$ := offset$
  ...
  
  let a$ := offset$ 
  mstore8(offset$, 103) 
  offset$ := add(offset$, 1)
  mstore(offset$, 3) 
  offset$ := add(offset$, 32) 
  let ignored_
  ignored_, offset$ := copy_from_pointer_to$(var0$, offset$) 
  ignored_, offset$ := copy_from_pointer_to$(bool_var1$, offset$) 
  ignored_, offset$ := copy_from_pointer_to$(str2$, offset$) 
\end{lstlisting}

В этом коде Yul переменные var0\$, bool\_var1\$ и str2\$ определены для целочисленных, булевых и строковых литералов, соответственно. Затем определяется список a\$. Длина списка хранится с помощью mstore, а фактические значения элементов списка копируются в память с помощью функции copy\_from\_pointer\_to\$ из внутренней стандартной библиотеки Elixireum, которая соответствующим образом обновляет offset\$.