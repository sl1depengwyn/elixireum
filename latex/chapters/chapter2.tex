\chapter{Literature Review}
\label{chap:lr}
\chaptermark{Second Chapter Heading}

This chapter serves as an introduction to the Ethereum ecosystem and offers an overview of the relevant literature.

In Section \ref{sec:evm}, we delve into the Ethereum Virtual Machine (EVM) and explore its gas consumption mechanism. Following that, in Section \ref{sec:langs}, we examine the existing languages compatible with the EVM. Section \ref{sec:cc} provides a concise overview of compiler construction, and in Section \ref{sec:ex}, we introduce the Elixir programming language. To wrap up, Section \ref{sec:conc} provides the concluding remarks for this chapter.

\section{Ethereum Virtual Machine}
\label{sec:evm}
Ethereum is a decentralized system, and at its core, the Ethereum Virtual Machine (EVM) is an essential component of the Ethereum blockchain. The EVM serves as the computational heart of the Ethereum network, enabling the execution of smart contracts and providing the foundation for a wide array of decentralized applications.

In the context of smart contract execution, it's important to mention the concept of gas limit. Gas limit is a critical aspect of Ethereum's execution model. Each operation and computation on the Ethereum Virtual Machine consumes a certain amount of gas, which is a measure of computational work. The gas limit is a cap set by the user or the entity initiating a contract execution, and it represents the maximum amount of gas they are willing to spend for that operation.

Gas limit, the EVM's stack-based architecture, and the wide set of available operations allow it to efficiently and securely for miners execute these smart contracts, granting it the status of a Turing-complete machine \cite{EthereumWhitepaper}. This level of computational flexibility empowers developers to create sophisticated programs.

\section{Existing EVM languages}
\label{sec:langs}
Official Ethereum documentation \cite{OfficialEthereumLanguages} enumerates only four languages that compile to EVM: Solidity, Vyper, Yul, and Fe. However, other attempts to create a language for EVM are known \cite{CommunityEthereumLanguages}.

Among the available languages for EVM, Solidity stands out as the most widely adopted and utilized one \cite{SolidityWidelyUsed, SolidityDevsChallenges}. This dominance is further emphasized by data presented in \cite{SolidityVyperGithubUsage}, which reveals that there are approximately 800 times more Solidity files on Github compared to Vyper files. Consequently, the majority of existing smart contracts on the Ethereum blockchain are written in Solidity. On one hand, the concentration of development and resources around a single language like Solidity can be viewed positively. It fosters a strong sense of community cohesion and ensures that the majority of developers are focused on refining and improving a single language, potentially enhancing its robustness and feature set. However, this dominance also brings significant challenges. The high prevalence of Solidity in the EVM ecosystem means that if a vulnerability or security flaw arises in the Solidity language, it affects a substantial portion of the smart contracts on the network. This centralized risk can be a double-edged sword, as a single point of failure in Solidity could have far-reaching consequences for the entire Ethereum blockchain. Furthermore, the Ethereum community is not without its criticisms of Solidity. Community members have voiced their concerns and challenges related to the language \cite{SolidityDevsChallenges}. These concerns range from the language's complexity to its lack of certain features, which may hinder the development of robust and secure smart contracts. So, decentralization and availability of choice are important, especially for such a decentralized ecosystem as blockchain.

\subsection{Solidity}

Solidity is a high-level, object-oriented programming, statically typed language designed specifically for the EVM. It has syntax similar to C++, Python, and Javascript \cite{SolidityInspirasion}. It supports multiple inheritance, complex user-defined types, and libraries as well as the number of other features \cite{SolidityFeatures}.

\subsection{Vyper}

Vyper contrasts significantly with Solidity, it is based on Python and extends it to suit smart contract development. Vyper aims for security and simplicity in terms of compiler implementation itself and code readability to be auditable more easily. For instance, it lacks a list of features that are considered harmful for code readability, and that makes the language more error-prone \cite{VyperDescription}.

\section{Compiler construction}
\label{sec:cc}

The process of compiler construction is a crucial bridge between high-level programming languages and the machine code that EVM understands. This process can be divided into three or four main stages, each playing a pivotal role in transforming human-readable code into executable instructions that can be processed by the EVM. Here is a general overview of these stages:

\subsection{Tokenization}
Tokenization is the initial step in the compilation process. During this stage, the source code is broken down into smaller units called tokens. These tokens are fundamental building blocks, including keywords, identifiers, operators, and constants. Tokenization simplifies the process of analyzing and parsing the code by providing a structured representation of the code's elements.

Tokenization facilitates syntactical and lexical analysis, ensuring that the code adheres to the language's grammar and can be properly understood.

\subsection{Parsing}

Parsing follows tokenization and focuses on the syntax of the source code. During parsing, the compiler checks the arrangement and structure of tokens to create a structured representation, often in the form of a syntax tree or abstract syntax tree (AST). This representation helps ensure that the code conforms to the language's grammar rules and can be further processed.

\subsection{Intermediate Representation (Optional)}

While not always a mandatory stage, the use of an intermediate representation can greatly enhance the efficiency and capabilities of a compiler. In the context of EVM, various intermediate representations like Yul and Yul+ are used for optimizing code. These representations help in enhancing code quality, optimizing performance, and preparing the code for final code generation.

Additionally, a language like Simplicity is employed for formal proofs. This stage is particularly important in scenarios where verification, security, and performance optimizations are key concerns.

\subsection{Code Generation}

The final stage of the compilation process involves code generation. During this stage, the compiler generates the actual machine code that the EVM can execute. The generated code is specific to the EVM's hardware architecture and represents a translation of the original high-level code into instructions that the EVM can understand and execute.

The code generation stage is crucial in ensuring that the compiled code is efficient and correctly reflects the intended behavior of the high-level source code.


In conclusion, compiler construction is fundamental to the implementation of the new language, enabling the translation of high-level languages into machine code. The stages of tokenization, parsing, optional intermediate representation, and code generation are essential components of this process.

\section{The Elixir language}
\label{sec:ex}

Elixir is a modern programming language that operates on top of the Erlang Virtual Machine. With its support for immutable variables, Elixir greatly enhances the clarity and simplicity of smart contract code. This immutability ensures that once data is defined, it cannot be altered, promoting predictability and security in the context of smart contract development.

One of Elixir's standout features is its metaprogramming capabilities. This functionality empowers developers to create domain-specific languages that are tailor-made for the intricacies of smart contract logic. This capability is invaluable as it allows developers to express contract logic in a manner that is both highly readable and closely aligned with the specific problem domain. By employing metaprogramming, smart contract development becomes more straightforward, and it becomes more accessible to a broader spectrum of developers.

As attested by O'Grady \cite{RedMonk}, Elixir stands strong among the top 50 programming languages. Remarkably, it surpasses even the popularity of Solidity, making it an attractive choice for Ethereum developers and thereby contributing to the expansion of the Ethereum community.

In summation, our decision to adopt Elixir as the language for our compiler and as the foundational framework for the Elixireum language is bolstered by its immutability, metaprogramming capabilities, and its prominence in the software development landscape. This choice ensures not only the simplicity and security of smart contract development but also the growth and diversification of the Ethereum ecosystem.

\section{Conclusion}
\label{sec:conc}

In conclusion, this chapter has emphasized two significant issues. Firstly, the overwhelming dominance of Solidity has brought substantial challenges to the Ethereum ecosystem. Secondly, the absence of functional languages for smart contract development has limited the utilization of functional paradigm advantages. Consequently, we have decided to develop Elixirium, a functional programming language built on Elixir, tailored specifically for smart contract development.
