\chapter{Literature Review}
\label{chap:lr}
\chaptermark{Second Chapter Heading}

This chapter introduces the reader to the Ethereum ecosystem and provide related literature.
Section \ref{sec:evm} describes Ethereum Virtual Machine (EVM) and its gas consumption mechanism. Section \ref{sec:langs} describes existing EVM languages. Section \ref{sec:cc} gives a brief overview of compiler construction. In section \ref{sec:ex} the Elixir language is introduced. To finalize, the chapter \ref{sec:conc} concludes this chapter, .

\section{Ethereum Virtual Machine}
\label{sec:evm}
Ethereum is a decentralized system, and at its core, the Ethereum Virtual Machine (EVM) is an essential component of the Ethereum blockchain. The EVM serves as the computational heart of the Ethereum network, enabling the execution of smart contracts and providing the foundation for a wide array of decentralized applications.

In the context of smart contract execution, it's important to mention the concept of gas limit. Gas limit is a critical aspect of Ethereum's execution model. Each operation and computation on the Ethereum Virtual Machine consumes a certain amount of gas, which is a measure of computational work. The gas limit is a cap set by the user or the entity initiating a contract execution, and it represents the maximum amount of gas they are willing to spend for that operation.

Gas limit, the EVM's stack-based architecture, and the wide set of available operations allow it to efficiently and securely for miners execute these smart contracts, granting it the status of a Turing-complete machine \cite{EthereumWhitepaper}. This level of computational flexibility empowers developers to create sophisticated programs.

\section{Existing EVM languages}
\label{sec:langs}
Official Ethereum documentation \cite{OfficialEthereumLanguages} enumerates only four languages that compiles to EVM: Solidity, Vyper, Yul and Fe. However, other attempts to create language for EVM are known \cite{CommunityEthereumLanguages}.

Among the available languages for EVM, Solidity stands out as the most widely adopted and utilized one \cite{SolidityWidelyUsed, SolidityDevsChallenges}. This dominance is further emphasized by data presented in \cite{SolidityVyperGithubUsage}, which reveals that there are approximately 800 times more Solidity files on Github compared to Vyper files. Consequently, it is evident that the majority of existing smart contracts on the Ethereum blockchain are written in Solidity. On one hand, the concentration of development and resources around a single language like Solidity can be viewed positively. It fosters a strong sense of community cohesion and ensures that the majority of developers are focused on refining and improving a single language, potentially enhancing its robustness and feature set. However, this dominance also brings significant challenges. The high prevalence of Solidity in the EVM ecosystem means that if a vulnerability or security flaw arises in the Solidity language, it affects a substantial portion of the smart contracts on the network. This centralized risk can be a double-edged sword, as a single point of failure in Solidity could have far-reaching consequences for the entire Ethereum blockchain. Furthermore, the Ethereum community is not without its criticisms of Solidity. Community members have voiced their concerns and challenges related to the language \cite{SolidityDevsChallenges}. These concerns range from the language's complexity to its lack of certain features, which may hinder the development of robust and secure smart contracts. So, decentralization and availability of choice is important, especially for such decentralized ecosystem as blockchain.

\subsection{Solidity}

Solidity is a high-level, object oriented programming, statically typed language designed specifically for the EVM. It has syntax similar to C++, Python and Javascript \cite{SolidityInspirasion}. It supports multiple inheritance, complex user-defined types, and libraries as well as number of other features \cite{SolidityFeatures}.

\subsection{Vyper}

Vyper contrasts significantly to Solidity, it is based on Python and extends it to suite smart contract development. Vyper aims security and simplicity in terms of compiler implementation itself and code readability to be auditable more easily. For instance, it lacks a list of features that considered harmful for code readability and that makes the language more error prone \cite{VyperDescription}.

\section{Compiler construction}
\label{sec:cc}

The process of compiler construction, is a crucial bridge between high-level programming languages and the machine code that EVM understands. This process can be divided into three or four main stages, each playing a pivotal role in transforming human-readable code into executable instructions that can be processed by the EVM. Here is a general overview of these stages:

\subsection{Tokenization}
Tokenization is the initial step in the compilation process. During this stage, the source code is broken down into smaller units called tokens. These tokens are fundamental building blocks, including keywords, identifiers, operators, and constants. Tokenization simplifies the process of analyzing and parsing the code by providing a structured representation of the code's elements.

Tokenization facilitates syntactical and lexical analysis, ensuring that the code adheres to the language's grammar and can be properly understood.

\subsection{Parsing}

Parsing follows tokenization and focuses on the syntax of the source code. During parsing, the compiler checks the arrangement and structure of tokens to create a structured representation, often in the form of a syntax tree or abstract syntax tree (AST). This representation helps ensure that the code conforms to the language's grammar rules and can be further processed.

\subsection{Intermediate Representation (Optional)}

While not always a mandatory stage, the use of an intermediate representation can greatly enhance the efficiency and capabilities of a compiler. In the context of EVM, various intermediate representations like Yul and Yul+ are used for optimizing code. These representations help in enhancing code quality, optimizing performance, and preparing the code for final code generation.

Additionally, a language like Simplicity is employed for formal proofs. This stage is particularly important in scenarios where verification, security, and performance optimizations are key concerns.

\subsection{Code Generation}

The final stage of the compilation process involves code generation. During this stage, the compiler generates the actual machine code that the EVM can execute. The generated code is specific to the EVM's hardware architecture and represents a translation of the original high-level code into instructions that the EVM can understand and execute.

The code generation stage is crucial in ensuring that the compiled code is efficient and correctly reflects the intended behavior of the high-level source code.


In conclusion, compiler construction is fundamental to the Ethereum ecosystem, enabling the translation of high-level languages into machine code that can be executed on the EVM. The stages of tokenization, parsing, optional intermediate representation, and code generation are essential components of this process. The flexibility to compile existing languages like Vyper further enriches the Ethereum development landscape, making it accessible to a wider range of developers and promoting the platform's growth and adoption.

\section{The Elixir language}
\label{sec:ex}

Elixir is a modern programming language, which is working on the top of Erlang VM. It has immutable variables that will make smart contracts' code more clear and straightforward. Elixir's metaprogramming capabilities enable the creation of domain-specific languages (DSLs). This is valuable for writing smart contracts, as it allows developers to express contract logic in a way that is highly readable and aligned with the problem domain. Metaprogramming can simplify contract development and make it more accessible to a wider range of developers. According to O'Grady \cite{RedMonk} Elixir is top 50 language. And moreover it's more popular than Solidity. Therefore using of Elixir will bring expand Ethereum community.

To sum up, we chose Elixir as a language for writing compiler, and also as a base for Elixireum language.

\section{Conclusion}
\label{sec:conc}



% \newpage


% \begin{longtable}{c|c}
% \caption[This is the title I want to appear in the List of Tables]{Simulation Parameters} \label{table:secsimulation_params} \\
% \hline
% A & B  \\
% \hline
% \endfirsthead
% \multicolumn{2}{@{}l}{} \\
% \hline
% A & B \\
% \hline
% \endhead
% \hline
%  \textbf{Parameter} & \textbf{Value}\\
%  \hline
%  Number of vehicles & $|\mathcal{V}|$\\
%  \hline
%  Number of RSUs & $|\mathcal{U}|$\\
%  \hline
%  RSU coverage radius & 150 m\\
%  \hline
%  V2V communication radius & 30 m\\
%  \hline
%  Smart vehicle antenna height & 1.5 m\\
%  \hline
%  RSU antenna height & 25 m\\
%  \hline
%  Smart vehicle maximum speed & $v_{max}$ m/s\\
%  \hline
%  Smart vehicle minimum speed & $v_{min}$ m/s\\
%  \hline
%  Common smart vehicle cache capacities & $[50, 100, 150, 200, 250]$ mb\\
%  \hline
%  Common RSU cache capacities & $[5000,1000,1500,2000,2500]$ mb\\
%  \hline
%  Common backhaul rates & $[75, 100, 150]$ mb/s\\
%  \hline
% \end{longtable}

% \begin{figure}[hbt]
% \centering
% \includegraphics[]{figs/inno.png}
% \caption{One kernel at $x_s$ (\emph{dotted kernel}) or two kernels at
% $x_i$ and $x_j$ (\textit{left and right}) lead to the same summed estimate
% at $x_s$. This shows a figure consisting of different types of
% lines. Elements of the figure described in the caption should be set in
% italics, in parentheses, as shown in this sample caption.}
% \label{fig:secex}
% \end{figure}

% This description implies several essential properties of the task at hand:
% \begin{enumerate}
%     \item Watermark must contain all necessary information, but still, be placeable and recognizable even on smaller images. The produced watermark must be compact but have the possibility to store enough information. 
%     \item To prevent easy tampering, the watermark must be invisible to the naked eye (and, preferably, to basic image parsing tools). If malefactor does not know about the existence of watermark, they might not even try to remove it and disable it. 
% \end{enumerate}
