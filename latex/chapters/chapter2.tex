\chapter{Literature Review}
\label{chap:lr}
\chaptermark{Second Chapter Heading}


\section{Ethereum Virtual Machine}
Ethereum is a decentralized system, and at its core, the Ethereum Virtual Machine (EVM) is an essential component of the Ethereum blockchain. The EVM serves as the computational heart of the Ethereum network, enabling the execution of smart contracts and providing the foundation for a wide array of decentralized applications.

In the context of smart contract execution, it's important to mention the concept of gas limit. Gas limit is a critical aspect of Ethereum's execution model. Each operation and computation on the Ethereum Virtual Machine consumes a certain amount of gas, which is a measure of computational work. The gas limit is a cap set by the user or the entity initiating a contract execution, and it represents the maximum amount of gas they are willing to spend for that operation.

Gas limit, the EVM's stack-based architecture, and the wide set of available operations allow it to efficiently and securely for miners execute these smart contracts, granting it the status of a Turing-complete machine \cite{EthereumWhitepaper}. This level of computational flexibility empowers developers to create sophisticated programs.

\section{Existing EVM languages}
Official Ethereum documentation \cite{OfficialEthereumLanguages} enumerates only four languages that compiles to EVM: Solidity, Vyper, Yul and Fe. However, other attempts to create language for EVM are known \cite{CommunityEthereumLanguages}.

Among the available languages for EVM, Solidity stands out as the most widely adopted and utilized one \cite{SolidityWidelyUsed, SolidityDevsChallenges}. This dominance is further emphasized by data presented in \cite{SolidityVyperGithubUsage}, which reveals that there are approximately 800 times more Solidity files on Github compared to Vyper files. Consequently, it is evident that the majority of existing smart contracts on the Ethereum blockchain are written in Solidity. On one hand, the concentration of development and resources around a single language like Solidity can be viewed positively. It fosters a strong sense of community cohesion and ensures that the majority of developers are focused on refining and improving a single language, potentially enhancing its robustness and feature set. However, this dominance also brings significant challenges. The high prevalence of Solidity in the EVM ecosystem means that if a vulnerability or security flaw arises in the Solidity language, it affects a substantial portion of the smart contracts on the network. This centralized risk can be a double-edged sword, as a single point of failure in Solidity could have far-reaching consequences for the entire Ethereum blockchain. Furthermore, the Ethereum community is not without its criticisms of Solidity. Community members have voiced their concerns and challenges related to the language \cite{SolidityDevsChallenges}. These concerns range from the language's complexity to its lack of certain features, which may hinder the development of robust and secure smart contracts. So, decentralization and availability of choice is important, especially for such decentralized ecosystem as blockchain.

\subsection{Solidity}

\subsection{Vyper}

\section{Market Research}

\section{Compiler construction}

The process of compiler construction, is a crucial bridge between high-level programming languages and the machine code that EVM understands. This process can be divided into three or four main stages, each playing a pivotal role in transforming human-readable code into executable instructions that can be processed by the EVM. Here is a general overview of these stages:

\subsection{Tokenization}
  Tokenization is the initial step in the compilation process. During this stage, the source code is broken down into smaller units called tokens. These tokens are fundamental building blocks, including keywords, identifiers, operators, and constants. Tokenization simplifies the process of analyzing and parsing the code by providing a structured representation of the code's elements.

  Tokenization facilitates syntactical and lexical analysis, ensuring that the code adheres to the language's grammar and can be properly understood.

\subsection{Parsing}

  Parsing follows tokenization and focuses on the syntax of the source code. During parsing, the compiler checks the arrangement and structure of tokens to create a structured representation, often in the form of a syntax tree or abstract syntax tree (AST). This representation helps ensure that the code conforms to the language's grammar rules and can be further processed.

\subsection{Intermediate Representation (Optional)}

  While not always a mandatory stage, the use of an intermediate representation can greatly enhance the efficiency and capabilities of a compiler. In the context of EVM, various intermediate representations like Yul and Yul+ are used for optimizing code. These representations help in enhancing code quality, optimizing performance, and preparing the code for final code generation.

  Additionally, a language like Simplicity is employed for formal proofs. This stage is particularly important in scenarios where verification, security, and performance optimizations are key concerns.

\subsection{Code Generation}

  The final stage of the compilation process involves code generation. During this stage, the compiler generates the actual machine code that the EVM can execute. The generated code is specific to the EVM's hardware architecture and represents a translation of the original high-level code into instructions that the EVM can understand and execute.

  The code generation stage is crucial in ensuring that the compiled code is efficient and correctly reflects the intended behavior of the high-level source code.


In conclusion, compiler construction is fundamental to the Ethereum ecosystem, enabling the translation of high-level languages into machine code that can be executed on the EVM. The stages of tokenization, parsing, optional intermediate representation, and code generation are essential components of this process. The flexibility to compile existing languages like Vyper further enriches the Ethereum development landscape, making it accessible to a wider range of developers and promoting the platform's growth and adoption.

\section{The Elixir language}

Elixir is a modern programming language, which is working on the top of Erlang VM. 

it's not popular as python or Javascript but it has own community, and it is in top 100 languages by TIOBE \cite{TIOBE}

To proceed with design of new language for smart contracts, we decided to choose elixir as a base. Because choice of existing language
1. will lower entry threshold into new language.
2. will attract Elixir developers to the Ethereum
3. allows to utilize existing compiler components such as lexer and parser

Such approach we can met in Vyper language which is built on the top of Python languag
\section{Conclusion}

% \newpage


% \begin{longtable}{c|c}
% \caption[This is the title I want to appear in the List of Tables]{Simulation Parameters} \label{table:secsimulation_params} \\
% \hline
% A & B  \\
% \hline
% \endfirsthead
% \multicolumn{2}{@{}l}{} \\
% \hline
% A & B \\
% \hline
% \endhead
% \hline
%  \textbf{Parameter} & \textbf{Value}\\
%  \hline
%  Number of vehicles & $|\mathcal{V}|$\\
%  \hline
%  Number of RSUs & $|\mathcal{U}|$\\
%  \hline
%  RSU coverage radius & 150 m\\
%  \hline
%  V2V communication radius & 30 m\\
%  \hline
%  Smart vehicle antenna height & 1.5 m\\
%  \hline
%  RSU antenna height & 25 m\\
%  \hline
%  Smart vehicle maximum speed & $v_{max}$ m/s\\
%  \hline
%  Smart vehicle minimum speed & $v_{min}$ m/s\\
%  \hline
%  Common smart vehicle cache capacities & $[50, 100, 150, 200, 250]$ mb\\
%  \hline
%  Common RSU cache capacities & $[5000,1000,1500,2000,2500]$ mb\\
%  \hline
%  Common backhaul rates & $[75, 100, 150]$ mb/s\\
%  \hline
% \end{longtable}

% \begin{figure}[hbt]
% \centering
% \includegraphics[]{figs/inno.png}
% \caption{One kernel at $x_s$ (\emph{dotted kernel}) or two kernels at
% $x_i$ and $x_j$ (\textit{left and right}) lead to the same summed estimate
% at $x_s$. This shows a figure consisting of different types of
% lines. Elements of the figure described in the caption should be set in
% italics, in parentheses, as shown in this sample caption.}
% \label{fig:secex}
% \end{figure}

% This description implies several essential properties of the task at hand:
% \begin{enumerate}
%     \item Watermark must contain all necessary information, but still, be placeable and recognizable even on smaller images. The produced watermark must be compact but have the possibility to store enough information. 
%     \item To prevent easy tampering, the watermark must be invisible to the naked eye (and, preferably, to basic image parsing tools). If malefactor does not know about the existence of watermark, they might not even try to remove it and disable it. 
% \end{enumerate}
