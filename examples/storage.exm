defmodule ETH.StorageA do
  alias Enum
  alias Blockchain.Storage
  alias Blockchain.{Storage, EVM, Storage.A}
  alias Blockchain.EVM, as: BlockchainEVM
  alias Blockchain.Types

  @int_test [type: Types.Int256.t()]
  @mapping_test [type: %{Types.Int256.t() => %{Types.Int256.t() => Types.Int256.t()}}]

  @spec increment_mapping(Types.Int256.t(), Types.Int256.t(), Types.Int256.t()) :: Types.Int256.t()
  def increment_mapping(a, b, c) do
    Storage.store(@mapping_test[a][b], Storage.get(@mapping_test[a][b]) + c)

    Storage.get(@mapping_test[a][b])
  end

  @spec increment_int(Types.Int256.t()) :: Types.Int256.t()
  def increment_int(a) do
    # c = Storage.get(@int_test) + 1
    Storage.store(@int_test, a)

    Storage.get(@int_test)
  end

  # @spec store(Types.Int256.t(), Types.Int256.t()) :: nil
  # def store(num, fake_num) do
  #   test = abc(num)
  #   Blockchain.Storage.store(@var_name, test)
  # end

  # @spec simple_arr_test(Types.Array.t(Types.Int256.t(), :dynamic), Types.Array.t(Types.Int256.t(), :dynamic)) :: Types.Array.t(Types.Int256.t(), :dynamic)
  # def simple_arr_test(_, arr) do
  #   arr
  # end

  # @spec dyn_dyn_arr_test(Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), :dynamic), Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), :dynamic)) :: Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), :dynamic)
  # def dyn_dyn_arr_test(_, arr) do
  #   arr
  # end

  # @spec dyn_st_arr_test(Types.Array.t(Types.Array.t(Types.Int256.t(), 3), :dynamic), Types.Array.t(Types.Array.t(Types.Int256.t(), 3), :dynamic)) :: Types.Array.t(Types.Array.t(Types.Int256.t(), 3), :dynamic)
  # def dyn_st_arr_test(_, arr) do
  #   arr
  # end

  # @spec st_dyn_arr_test(Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), 3), Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), 3)) :: Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), 3)
  # def st_dyn_arr_test(_, arr) do
  #   arr
  # end

  # @spec simple_tuple(Types.Int256.t(), Types.Tuple.t(Types.Int256.t(), Types.Int256.t())) :: Types.Tuple.t(Types.Int256.t(), Types.Int256.t())
  # def simple_tuple(_, tuple) do
  #   tuple
  # end

  # @spec hard_tuple(Types.Tuple.t(Types.Int256.t(), Types.Array.t(Types.Int256.t(), :dynamic), Types.Array.t(Types.Int256.t(), 2), Types.Array.t(Types.Int256.t(), :dynamic))) :: Types.Tuple.t(Types.Int256.t(), Types.Array.t(Types.Int256.t(), :dynamic), Types.Array.t(Types.Int256.t(), 2), Types.Array.t(Types.Int256.t(), :dynamic))
  # def hard_tuple(tuple) do
  #   tuple
  # end

  # @spec retrieve() :: Blockchain.Types.Int256.t()
  # def retrieve() do
  #   Storage.get(@var_name)
  # end

  # defp abc(qwe) do
  #   qwe + 1 + get_0()
  # end

  # defp get_0() do
  #   100
  # end
end
