defmodule ETH.StorageA do
  alias Enum
  alias Blockchain.Storage
  alias Blockchain.{Storage, EVM, Storage.A}
  alias Blockchain.EVM, as: BlockchainEVM
  alias Blockchain.Types

  # @event_name [event_inputs: []]
  @int_test [type: Types.Int256.t()]
  @mapping_test [type: %{Types.Int256.t() => %{Types.Int256.t() => Types.Int256.t()}}]

  @spec constructor(Types.Int256.t()) :: nil
  def constructor(a) do
    Storage.store(@int_test, a)
  end

  @spec test_address() :: Types.Address.t()
  def test_address() do
    ~ADDRESS(0x8a258309B8177Df36c48de82885A56cCF576979C)
  end

  @spec abc(Types.Int256.t()) :: Types.Int256.t()
  def abc(num) do
    10 + num
  end

  @spec return_origin() :: Types.Address.t()
  def return_origin() do
    Blockchain.tx_origin()
  end

  @spec get_int_test() :: Types.Int256.t()
  def get_int_test() do
    Storage.get(@int_test)
  end

  # Blockchain.emit_event(@event_name, hjj: 678, jk: 678)

  # @spec increment_mapping(Types.Int256.t(), Types.Int256.t(), Types.Int256.t()) :: Types.Int256.t()
  # def increment_mapping(a, b, c) do
  #   Storage.store(@mapping_test[a][b], Storage.get(@mapping_test[a][b]) + c)

  #   Storage.get(@mapping_test[a][b])
  # end

  # @spec increment_int(Types.Int256.t()) :: Types.Int256.t()
  # def increment_int(a) do
  #   # c = Storage.get(@int_test) + 1
  #   Storage.store(@int_test, a)

  #   Storage.get(@int_test)
  # end

  # @spec store(Types.Int256.t(), Types.Int256.t()) :: nil
  # def store(num, fake_num) do
  #   test = abc(num)
  #   Blockchain.Storage.store(@var_name, test)
  # end

  # @spec simple_arr_test(Types.Array.t(Types.Int256.t(), :dynamic), Types.Array.t(Types.Int256.t(), :dynamic)) :: Types.Array.t(Types.Int256.t(), :dynamic)
  # def simple_arr_test(_, arr) do
  #   arr
  # end

  # @spec dyn_dyn_arr_test(Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), :dynamic), Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), :dynamic)) :: Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), :dynamic)
  # def dyn_dyn_arr_test(_, arr) do
  #   arr
  # end

  # @spec dyn_st_arr_test(Types.Array.t(Types.Array.t(Types.Int256.t(), 3), :dynamic), Types.Array.t(Types.Array.t(Types.Int256.t(), 3), :dynamic)) :: Types.Array.t(Types.Array.t(Types.Int256.t(), 3), :dynamic)
  # def dyn_st_arr_test(_, arr) do
  #   arr
  # end

  # @spec st_dyn_arr_test(Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), 3), Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), 3)) :: Types.Array.t(Types.Array.t(Types.Int256.t(), :dynamic), 3)
  # def st_dyn_arr_test(_, arr) do
  #   arr
  # end

  # @spec simple_tuple(Types.Int256.t(), Types.Tuple.t(Types.Int256.t(), Types.Int256.t())) :: Types.Tuple.t(Types.Int256.t(), Types.Int256.t())
  # def simple_tuple(_, tuple) do
  #   tuple
  # end

  # @spec hard_tuple(Types.Tuple.t(Types.Int256.t(), Types.Array.t(Types.Int256.t(), :dynamic), Types.Array.t(Types.Int256.t(), 2), Types.Array.t(Types.Int256.t(), :dynamic))) :: Types.Tuple.t(Types.Int256.t(), Types.Array.t(Types.Int256.t(), :dynamic), Types.Array.t(Types.Int256.t(), 2), Types.Array.t(Types.Int256.t(), :dynamic))
  # def hard_tuple(tuple) do
  #   tuple
  # end

  # @spec retrieve() :: Blockchain.Types.Int256.t()
  # def retrieve() do
  #   Storage.get(@var_name)
  # end

  # defp abc(qwe) do
  #   qwe + 1 + get_0()
  # end

  # defp get_0() do
  #   100
  # end
end
